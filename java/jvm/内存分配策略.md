## 指针碰撞 

> - **原理**
>
>   >在内存分配过程中，如果内存是规整的（取决于垃圾收集器是否具有内存整理功能），即分配的内存都位于某一端，而空闲内存都位于另一端，此时有一个指针，指向空闲内存的的起始位置。当需要分配内存时，只需要将指针向空闲内存区域移动一段与分配内存大小相等的距离即可。
>   >
>   >> 在堆内存的年轻代的 Eden 区和Survivor 区，当内存是规整时，会使用指针碰撞的方式进行内存分配。例如，当有新的对象需要分配内存时，如果内存足够，直接在指针所指位置分配相应大小的内存，并移动指针即可。
>
> - **举例**
>
>   > 假设内存是从低地址，到高地址方向分配，有一个指向当前空闲内存起始位置的指针，当分配大小为n的内存时，将指针加n即可完成分配。
>
> - **优点**
>
>   >内存分配速度非常快，因为他只需要简单的指针操作，没有复杂的查找和整理过程。
>
> - **缺点**
>
>   >只能用于内存规整的情况，如果内存中有多个空闲块分散在各个位置，这种策略无法工作。

------------

## 空闲列表

> - **原理**
>
>   >系统维护一个关于空闲内存块的列表，当需要分配内存时，在空闲列表内查找合适大小的空闲块进行分配。查找的方式可以有多种，比如首次适应算法（查找空闲列表中第一个足够大的空闲块进行分配）、最佳适应算法（查找空闲列表中最接近所需大小的空闲块进行分配）等。
>   >
>   >> 老年代的内存分配通常会使用空闲列表的方式。因为老年代的内存分配相对不那么频繁，而且可能存在许多不规则的空闲内存块。当需要分配内存时，会在空闲列表中查找合适的空闲块进行分配。
>
> - **举例** 
>
>   > 空闲列表记录了各个空闲块的大小和起始地址，当一个大小为m的内存分配请求到达时，按照选定的算法在空闲列表中查找合适的空闲块。
>
> - **优点** 
>
>   >能够更好的利用不规则的空闲内存块，对于内存碎片较多的情况仍然有效。
>
> - **缺点** 
>
>   > 内存分配和回收操作相对复杂，因为需要在空闲列表中进行查找和更新操作，这可能会带来一定的性能开销。

------------------------------------------

## TLAB（Threah Local Allocation Buffer）本地线程分配缓冲区

>- **原理** 
>
>  >为每个线程分配一个本地线程缓冲区（TLAB）。线程在自己的TLAB中进行内存分配，当TLAB中的内存用完时，**再从共享的堆内存中分配一个新的TLAB**。
>
>- **举例** 
>
>  > 每个Java线程在Java堆中分配内存时，首先会在自己的TLAB中分配，如果TLAB不足，才会触发在堆内存中分配。
>
>- **优点**
>
>  > 可以有效避免线程之间的内存分配竞争，因为每个线程都有自己的线程本地缓冲区，大大提高了内存分配的并发性能。
>
>- **缺点** 
>
>  > 需要合理设置TLAB的大小，如果设置过小，会频繁的从共享堆内存分配TLAB，增加开销，如果设置过大，可能会导致内存浪费。

-----------







