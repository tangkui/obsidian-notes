

## 栈上分配 

> - 在Java中，栈上分配（Stack Allocation）是一种内存分配策略，**它将对象分配在栈内存中**，而不是堆内存中，这种策略可以提高内存分配和回收效率，减少垃圾回收的开销。不过想要将对象在栈上进行分配，**需要先开启标量替换以及逃逸分析。**
>
> - 栈内存的分配和回收非常高效，因为栈内存的分配和回收是自动的，遵循后进先出（LIFO）的原则。
>
> - 对象的标量通常存储在栈帧的局部变量表中。
>
>   > [!IMPORTANT]
>   >
>   > 决定一个对象能在栈上分配的因素：
>   >   1、对象能够通过标量替换分解成一个个标量。
>   >   2、对象在栈帧级作用域不可逃逸。

### 逃逸分析

> -  逃逸分析是一种编译器优化技术，用于判断对象是否会在当前线程或栈帧之外被访问。
> - 编译器会分析对象的使用范围，判断对象是否会被传递给其他线程或方法。
> - 当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸.

-------------------------------------------

> - ①栈帧（方法）逃逸：当前方法内定义了一个局部变量逃出了当前方法或栈帧。
>
> - ②线程逃逸：当前方法内定义了一个局部变量逃出了当前线程能够被其他线程访问。
>
> > [!TIP]
> >
> > 全局变量赋值逃逸：当前对象被赋值给类属性、静态属性 。
> >
> > 参数赋值逃逸：当前对象被当作参数传递给另一个方法。
> >
> > 方法返回值逃逸：当前对象被当做返回值return

### 标量替换

> - **定义：**
>
>   > 标量替换是一种编译器优化技术，将对象拆分为多个标量（不可分割的量，指基本数据类型和reference类型），直接在栈上分配这些标量，而不是分配整个对象（聚合量）。
>
> - **工作原理：**
>
>   > 如果逃逸分析确定一个对象不会逃逸，编译器可以将对象的成员变量拆分为单独的标量，并将这些标量分配在栈上。
>   >
>   > 这样可以避免为整个对象分配内存，从而减少内存分配和回收的开销。
>
> - **优点：** 
>
>   >1. 能够节省堆内存，因为进行标量替换之后的对象可以在栈上进行内存分配。
>   >2. 相对运行而言省去了在堆中查找对象引用的过程，速度会更快一些。
>   >3. 对象在栈上分配空间，所以随着方法结束和线程栈的弹出自动销毁，不需要GC的介入。

## 栈相关

> - **栈是先进后出的原因**
>
> > - 栈（Stack）是一种只能在一端进行插入或删除操作的线性表。这个特殊的一端被称为栈顶（Top），另一端被称为栈底（Bottom）。在栈操作中，数据元素的插入称为入栈（Push）操作，数据元素的删除称为出栈（Pop）操作。
> > - 栈的这种先进后出的特性是由其操作规则所决定的。当元素依次入栈时，后入栈的元素位于栈顶，而出栈操作只能从栈顶进行。例如，假设有元素 A、B、C 依次入栈。首先 A 进入栈底，接着 B 进入栈顶，此时 A 在 B 的下方；然后 C 进入栈顶，此时栈顶元素是 C。出栈时，必须先取出 C，然后再是 B，最后是 A。这就是先进后出的特点。

>- **栈内存分配和回收高效的缘由**
>
>> - 栈内存的分配和回收主要依赖于栈指针（或称为栈顶指针）的操作。在程序运行时，当需要为一个局部变量或者函数调用的上下文分配内存时，只需要简单地将栈顶指针向下移动（假设栈是向下生长的），就可以开辟出一块连续的内存空间。
>> - 例如，假设栈顶指针的初始位置是 0x1000，当分配一个大小为 4 字节的局部变量时，栈顶指针变为 0x0FFC（向下移动 4 个字节）。当这个局部变量不再需要时，通过简单地将栈顶指针向上移动（恢复到原来的 0x1000）就可以回收内存。
>> - 这种内存分配和回收方式不需要复杂的内存管理算法，也不需要像堆内存那样进行查找合适的空间或者内存回收的标记 - 清理过程。所以栈内存的分配和回收非常高效。

> - **栈内存分配和回收自动的原因**
>
> > - 栈内存的分配和回收是由程序的编译器和运行时环境自动完成的。在编译阶段，编译器会根据函数定义中的局部变量声明、函数调用参数等信息，确定每个函数在执行过程中所需要的栈空间大小。
> > - 当函数被调用时，运行时环境会自动根据编译器预先确定的大小，通过调整栈顶指针来分配相应的栈内存，用于存储函数的局部变量、返回地址等信息。而当函数执行结束时，运行时环境也会自动将栈顶指针恢复到函数调用前的状态，从而自动回收了这部分栈内存。
> > - 例如，在 C 语言中，当你定义一个函数，其中包含一些局部变量时，编译器会计算出这些局部变量所需的内存量。在函数调用时，这些变量的内存分配是自动的，函数返回后，这些内存也会自动被回收，程序员不需要手动进行内存的分配和释放操作。
