---
title: 锁
tags:
  - 锁
  - CAS
  - AQS
  - 偏向锁
---

## CAS（Compare-And-Swap）

CAS 是 Compare - And - Swap（比较并交换）的缩写，它是一种无锁算法的实现原理，被广泛应用在多线程并发编程中。以下是 CAS 的实现原理：

### 基本概念

  * CAS 包含三个操作数，分别是内存值 V、旧的预期值 A 和新值 B。
  * 当且仅当内存值 V 等于旧预期值 A 时，将内存值 V 更新为新值 B，否则就什么都不做。整个过程是一个原子操作。

### 底层实现原理

  * 在 Java 中，CAS 是通过Unsafe类中的compareAndSwapInt和compareAndSwapLong等方法实现的，这些方法底层是通过操作系统的原子指令实现的，如在 x86 架构下，使用的是 lock cmpxchg 指令。
  * 当一个线程执行 CAS 操作时，它会先把内存中的值加载到寄存器中，然后将寄存器中的值与预期旧值进行比较。如果相等，则将新值写入内存；如果不相等，则会重新读取内存中的值并再次比较，直到成功更新或者放弃操作。

### 优点和缺点

  * **优点** ：CAS 操作是原子性的，可以保证在多线程环境下对共享变量的操作是安全的，避免了使用传统锁机制所带来的线程阻塞、死锁等问题，提高了程序的并发性能。
  * **缺点** ：**CAS 存在ABA问题**，即当变量 V 在线程准备进行 CAS 操作时，其值被改成了 A，然后又被改回了原来的值 V，此时 CAS 操作会误认为该变量没有被修改过，从而导致操作成功，但实际上该变量已经被修改过两次。为了解决这个问题，可以使用带有版本号的 CAS，如 Java 中的AtomicStampedReference类。

CAS 的实现原理使其成为一种高效的无锁编程技术，在许多场景下都能有效地提高并发程序的性能和可靠性。

-------

## 问题 1

> **内存值 V、旧的预期值 A 和新值 B。这三个值的来源是什么？**
>
> 在 CAS（Compare - And - Swap）操作中，内存值 V、旧的预期值 A 和新值 B 的来源如下：
>
> ### 内存值 V
>
>   * 内存值 V 是被多个线程共享的变量，存储在内存中。它通常是程序中需要进行原子操作的共享数据，比如一个计数器变量、一个状态标志等。多个线程都可能对该变量进行读取和更新操作。
>
> ### 旧的预期值 A
>
>   * 旧的预期值 A 是当前线程在准备进行 CAS 操作时所期望的内存值 V 的当前值。在执行 CAS 操作之前，线程会先读取内存值 V 的当前值，并将其作为旧的预期值 A。这是因为线程希望在没有其他线程对共享变量进行修改的情况下，将内存值更新为新值 B。只有当内存值 V 的当前值仍等于旧的预期值 A 时，才认为没有其他线程对该共享变量进行修改，此时才能安全地执行更新操作。
>   * 例如，线程在进行一次原子递增操作时，先读取当前的内存值 V 为 5，那么旧的预期值 A 就是 5。然后线程希望将内存值更新为 5 + 1 = 6（新值 B）。如果在读取内存值到执行 CAS 操作期间，没有其他线程修改这个内存值，那么内存值 V 仍然等于旧的预期值 A（5），CAS 操作就会将内存值更新为 6。
>
> ### 新值 B
>
>   * 新值 B 是当前线程希望将内存值 V 更新为目标值。这个新值通常由线程根据程序逻辑计算得出，用于反映线程对共享变量的修改意图。比如在原子递增操作中，新值 B 就是旧的预期值 A 加 1；在原子更新操作中，新值 B 可能是根据旧的预期值 A 和其他相关数据计算得出的新状态或新数据。
>
> 在实际的编程语言实现中，如 Java 中的 `AtomicInteger` 类等原子类，提供了基于 CAS 操作的方法来对共享变量进行安全的更新。这些方法内部会根据用户提供的代码逻辑来确定旧的预期值 A 和新值 B，然后执行 CAS 操作来更新内存值 V。

-----------

## 问题2 

> **当一个线程执行 CAS 操作时，底层的 lock cmpxchg 指令会将 CPU 的缓存行进行锁定，确保在该操作执行期间，其他线程无法对该内存地址进行读写操作。 既然锁定了，不允许其他线程读写，那么，多线程环境下又为什么会产生ABA问题呢？**
>
> CAS（Compare-And-Swap）的底层实现确实依赖于像`lock cmpxchg`这样的硬件指令，这些指令在执行时会锁定缓存行，以确保操作的原子性。这种锁定机制虽然会阻塞其他线程对该内存地址的访问，但与传统的锁机制相比，CAS仍有显著的优势。
>
> ### **1. CAS的锁定范围更小**
>
> CAS操作锁定的是特定的内存地址（缓存行），而不是像传统锁那样锁定一段代码或一个对象。这意味着在多线程环境下，只有那些尝试访问同一内存地址的线程会受到影响，而其他线程可以继续执行与该内存地址无关的操作。这种细粒度的锁定机制使得系统整体的并行度更高。
>
> ### **2. CAS不会导致线程阻塞和上下文切换**
>
> 传统锁机制通过阻塞线程来实现同步，被阻塞的线程会进入等待状态，直到锁被释放。这种阻塞会导致线程的上下文切换，而上下文切换是一个相对耗时的操作，会显著影响性能。相比之下，CAS操作不会阻塞线程，它采用了“忙等待”（busy-wait）的方式。如果CAS操作失败，线程不会被阻塞，而是会重试操作，直到成功。这种方式避免了线程的上下文切换，减少了性能开销。
>
> ### **3. CAS适用于多核处理器环境**
>
> 现代计算机大多采用多核处理器架构。在多核环境中，CAS操作的性能优势更加明显。由于CAS操作的原子性是由硬件保证的，它可以在多个核心之间高效地同步数据，而不需要像传统锁那样引入复杂的锁管理机制。
>
> ### **4. CAS操作的性能优势**
>
> 在低 contention（竞争）的情况下，CAS操作的性能通常优于传统的锁机制。这是因为CAS操作避免了锁的获取和释放开销，以及线程阻塞和唤醒的开销。在高 contention 的情况下，虽然CAS可能会因为频繁重试而导致较高的 CPU 使用率，但在许多实际场景中，这种开销仍然低于传统锁机制的开销。
>
> ### **5. CAS的灵活性**
>
> CAS操作可以用于实现各种无锁数据结构和算法，这些数据结构和算法在多线程环境下具有更高的性能和可扩展性。传统的锁机制往往难以实现这种灵活性，因为锁的粒度和范围通常比较固定。
>
> ### **6. CAS的适用场景**
>
> 尽管CAS有诸多优势，但它并不适用于所有场景。在高 contention 的情况下，或者在需要复杂同步逻辑的场景中，传统的锁机制可能更适合。此外，CAS操作可能会引入 ABA 问题（虽然可以通过引入版本号等方式解决），这也需要根据具体需求权衡。
>
> ### **总结**
>
> 虽然CAS操作在底层确实会锁定特定的内存地址，但这种锁定范围非常小，且不会导致线程阻塞和上下文切换。与传统锁机制相比，CAS在多线程环境下提供了更高的性能和灵活性，尤其是在低 contention 和多核处理器环境中。因此，CAS在现代并发编程中被广泛使用，尤其是在实现无锁数据结构和高性能并发算法时。

-----

## 问题3 

> **busy-wait和阻塞有什么区别?** 
>
> **1. 定义**
>
> - **busy - wait（忙等待）**：
>   - 忙等待是一种编程技术，它让一个线程不断循环检查某个条件是否为真。在这个过程中，线程保持活跃状态，占用 CPU 资源，不做任何其他有用的工作，只是等待条件满足。
>   - 例如，在 CAS 操作中，如果 CAS 操作失败（因为内存值被其他线程修改），线程不会放弃 CPU 执行权，而是会一直循环重新尝试 CAS 操作，直到成功。
> - **阻塞**：
>   - 阻塞是指线程在等待某个事件发生时，被系统暂停执行，进入等待状态。处于阻塞状态的线程不会占用 CPU 资源，操作系统会把 CPU 执行权交给其他线程。
>   - 比如，当一个线程试图获取一个已经被其他线程锁定的互斥锁时，该线程会被阻塞，直到锁被释放。
>
> **2. CPU 资源占用情况**
>
> - **busy - wait**：
>   - 忙等待会持续占用 CPU 资源。线程不断地执行循环，检查条件，这会导致 CPU 的使用率较高。如果多个线程都在忙等待，可能会使 CPU 负载过重。
>   - 例如，在一个双核 CPU 系统中，如果两个线程都在忙等待，它们可能会各自占据一个 CPU 核心，不断地循环检查条件，没有给其他线程留下足够的 CPU 时间片。
> - **阻塞**：
>   - 阻塞的线程不会占用 CPU 资源。操作系统会将阻塞的线程从 CPU 的运行队列中移除，把 CPU 执行权分配给其他就绪状态的线程。
>   - 例如，当线程 A 阻塞等待某个 I/O 操作完成时，线程 B 可以获得 CPU 执行权，继续执行其他任务，这样可以更高效地利用 CPU 资源。
>
> **3. 线程状态**
>
> - **busy - wait**：
>   - 在忙等待过程中，线程始终处于运行状态。它只是在循环中执行简单的条件检查操作，没有真正进入等待状态。
>   - 从操作系统调度的角度来看，线程仍然是就绪的或者正在运行的，调度器会为它分配 CPU 时间片。
> - **阻塞**：
>   - 阻塞的线程会进入等待状态。这是操作系统定义的一种线程状态，代表线程暂时无法执行，需要等待某个特定事件发生才能继续运行。
>   - 操作系统调度器不会为处于等待状态的线程分配 CPU 时间片，只有当阻塞的原因消除后（如等待的锁被释放、等待的 I/O 操作完成等），线程才会被唤醒并重新进入就绪状态。
>
> **4. 适用场景**
>
> - **busy - wait**：
>   - 忙等待适用于等待时间很短的情况。如果线程预计等待的时间非常短暂，使用忙等待可能比进行线程阻塞和唤醒操作的开销更小。
>   - 例如，在等待一个非常快速的硬件事件完成时，使用忙等待可以让线程在硬件事件完成后立即继续执行，而不需要经过复杂的阻塞和唤醒流程。
> - **阻塞**：
>   - 阻塞适用于等待时间较长或者等待事件不确定的情况。当线程需要等待其他线程完成一个复杂的任务或者等待外部 I/O 操作完成时，阻塞是一种更合适的机制。
>   - 例如，当一个线程需要等待从网络读取大量数据时，使用阻塞操作可以让线程在数据到达之前释放 CPU 资源，避免浪费 CPU 时间。
>
> **5. 实现复杂度**
>
> - **busy - wait**：
>   - 忙等待的实现相对简单。它通常通过一个循环结构来不断检查某个条件，如 `while (condition) {}` 这样的代码结构。
>   - 但是，需要谨慎使用忙等待，因为不当的使用可能会导致 CPU 资源浪费和系统性能下降。
> - **阻塞**：
>   - 阻塞的实现相对复杂，通常依赖于操作系统的功能。它涉及到线程调度、等待队列等操作系统的内部机制。
>   - 在编程语言中，阻塞通常通过调用系统提供的同步原语（如互斥锁、信号量、条件变量等）来实现。例如，在 Java 中，使用 `Object.wait()` 方法可以让线程阻塞，直到其他线程调用 `Object.notify()` 或 `Object.notifyAll()` 方法来唤醒它。

## 原子性  

> 原子性是指一个操作在执行时，要么完全执行，要么完全不执行，整个操作过程不可被其他操作打断或干扰。CAS 操作之所以具有原子性，主要依赖于以下方面：
>
> ### 硬件层面的保证
>
> - 现代计算机的 CPU 在底层实现了一系列的原子指令，CAS 操作就是基于这些原子指令来实现的。例如，在 x86 架构下，**lock cmpxchg** 指令可以实现 CAS 的原子性操作。
> - **当一个线程执行 CAS 操作时，底层的 lock cmpxchg 指令会将 CPU 的缓存行进行锁定，确保在该操作执行期间，其他线程无法对该内存地址进行读写操作，从而保证整个 CAS 操作的原子性**。
>
> ### 操作步骤的不可分割性
>
> - CAS 操作是一个单一的、不可分割的操作步骤。它包含了读取内存值、比较旧值以及更新新值的过程，这些步骤在底层被整合到一个原子指令中。
> - 在执行 CAS 操作时，其他线程无法在 CAS 操作的中间过程插入自己的读写操作。也就是说，CAS 操作要么完整地执行，要么不执行，中间状态不会被其他线程看到，从而保证了操作的原子性。
>
> ### 操作系统层面的原子性保证
>
> - 有些操作系统底层也会提供一些机制来保证某些操作的原子性，CAS 操作也可能基于这些机制实现。例如，通过信号量等同步原语，可以确保在执行 CAS 操作时，其他线程不会干扰该操作。
>
> 通过这些底层机制的保证，CAS 操作能够作为一个完整的、不可分割的原子操作来执行，从而在多线程环境下实现对共享变量的安全访问和更新。

------

## 偏向锁  

偏向锁是JVM中一种针对同一线程多次获取同一锁的优化机制，它假设在大多数情况下，锁不会被多个线程竞争，而是一直被同一个线程所持有。下面详细介绍偏向锁的原理、优点、缺点以及应用场景：

### 偏向锁的原理

- **初始状态**：锁对象的Mark Word存储对象的运行时数据，包括锁信息、哈希码、GC分代年龄等，此时锁处于未锁定状态。
- **偏向锁获取**：当一个线程第一次获取锁时，JVM会将Mark Word复制到该线程的栈帧中，并将锁标记为偏向模式，同时记录线程ID等信息。之后该线程再次获取锁时，只需检查Mark Word中的线程ID是否与自身匹配，匹配则直接获取锁，无需进行同步操作。
- **偏向锁撤销**：当另一个线程尝试获取偏向锁时，偏向锁会被撤销，升级为轻量级锁或重量级锁。

### 优点

- **减少同步开销**：同一线程再次获取锁时，无需进行复杂的同步操作，如获取和释放锁，只需简单检查偏向锁信息是否匹配。
- **提高程序性能**：在偏向锁适用场景下，能有效减少线程同步的时间和资源消耗，提升程序的执行效率。
- **简化锁操作**：对于同一线程多次获取同一锁的情况，偏向锁简化了锁的获取和释放流程。

### 缺点

- **不适用于多线程竞争场景**：在多线程频繁竞争同一锁的情况下，偏向锁的撤销和升级操作会增加额外的开销。
- **增加了锁机制的复杂性**：偏向锁的引入使锁的实现和管理更加复杂，需要更多的逻辑来处理偏向锁的获取、撤销和升级。
- **可能导致锁膨胀**：在某些情况下，偏向锁可能会升级为更重量级的锁，从而影响程序的性能。

### 应用场景

- **单线程频繁访问共享资源**：如日志记录模块，线程频繁调用同步方法写日志，偏向锁减少同步开销。
- **线程局部缓存**：线程维护本地缓存更新用户会话信息，偏向锁减少每次更新缓存同步操作。
- **任务队列处理**：线程从队列取任务执行，偏向锁减少取任务时同步开销。
- **计数器**：线程统计服务调用次数更新计数器，偏向锁减少更新计数器时同步开销。

---------

## 偏向锁在JVM中是如何升级的？

> 偏向锁在 JVM 中的升级过程是一个从偏向锁到轻量级锁，再到重量级锁的过程，这个过程是基于锁的竞争程度来决定的。以下是偏向锁升级的详细步骤：
>
> ### 1. 初始化和偏向锁获取
>
> - **初始状态**：对象头的 Mark Word 包含锁信息、哈希码、GC 分代年龄等信息，默认处于无锁状态。
> - **偏向锁获取**：当一个线程第一次获取锁时，JVM 会将 Mark Word 复制到该线程的栈帧中，并将锁标记为偏向模式，同时记录线程 ID 等信息。此时，偏向锁状态被标记为 1，并且偏向锁的线程 ID 被设置为当前线程的 ID。
>
> ### 2. 偏向锁撤销
>
> - **竞争检测**：当另一个线程尝试获取偏向锁时，JVM 会检测到锁已经被偏向。此时，JVM 会尝试撤销偏向锁。
> - **偏向锁撤销条件**：在撤销偏向锁之前，JVM 会检查当前线程是否仍然持有偏向锁。如果线程仍然持有偏向锁，则需要执行偏向锁的撤销操作。
>
> ### 3. 升级到轻量级锁
>
> - **偏向锁撤销**：在偏向锁的撤销过程中，JVM 会将偏向锁的状态从偏向模式恢复到无锁状态。这个操作涉及到原子操作，以确保线程安全。
> - **轻量级锁获取**：在撤销偏向锁之后，锁会被升级为轻量级锁。此时，线程会尝试通过 CAS 操作来获取锁。如果获取成功，锁保持在轻量级锁状态；如果获取失败，说明有其他线程在竞争锁，此时可能会升级到重量级锁。
>
> ### 4. 升级到重量级锁
>
> - **竞争检测**：如果多个线程同时尝试获取轻量级锁，导致 CAS 操作频繁失败，JVM 会将锁升级为重量级锁。
> - **重量级锁获取**：在重量级锁状态下，线程会进入等待队列，等待其他线程释放锁。重量级锁使用操作系统的互斥量（mutex）来实现，线程可能会被挂起和恢复，这会带来较大的性能开销。
>
> ### 具体过程示例
>
> java
>
> 复制
>
> ```java
> public class BiasedLockUpgradeExample {
>     private Object lock = new Object();
> 
>     public void methodA() {
>         synchronized (lock) {
>             // 业务逻辑
>         }
>     }
> 
>     public void methodB() {
>         synchronized (lock) {
>             // 业务逻辑
>         }
>     }
> 
>     public static void main(String[] args) {
>         BiasedLockUpgradeExample example = new BiasedLockUpgradeExample();
> 
>         // 线程1获取偏向锁
>         Thread thread1 = new Thread(() -> {
>             example.methodA();
>         });
>         thread1.start();
>         try {
>             thread1.join();
>         } catch (InterruptedException e) {
>             e.printStackTrace();
>         }
> 
>         // 线程2尝试获取锁，导致偏向锁撤销并升级到轻量级锁
>         Thread thread2 = new Thread(() -> {
>             example.methodB();
>         });
>         thread2.start();
>         try {
>             thread2.join();
>         } catch (InterruptedException e) {
>             e.printStackTrace();
>         }
>     }
> }
> ```
>
> ### 偏向锁升级的总结
>
> - **偏向锁到轻量级锁**：当另一个线程尝试获取已被偏向的锁时，偏向锁会被撤销，并升级为轻量级锁。这个过程涉及到 CAS 操作和其他线程安全机制。
> - **轻量级锁到重量级锁**：如果多个线程持续竞争锁，导致 CAS 操作频繁失败，锁会被升级为重量级锁。重量级锁使用操作系统的互斥量，线程可能会被挂起和恢复，带来较大的性能开销。
>
> ### 注意事项
>
> - **偏向锁的撤销**：偏向锁的撤销是一个相对复杂的操作，涉及到线程之间的协调和原子操作。在高并发场景下，频繁的偏向锁撤销和升级可能会带来性能开销。
> - **锁的粒度控制**：在实际开发中，合理控制锁的粒度和使用场景，可以有效减少锁升级的频率，从而提高程序的性能。
>
> 通过理解偏向锁的升级机制，可以更好地优化多线程程序中的锁使用，避免不必要的性能开销。

------

## 轻量级锁和重量级锁

> 在 Java 中，锁机制是实现线程同步的重要手段。轻量级锁和重量级锁是 Java 中两种不同级别的锁机制，它们在实现方式、性能开销和适用场景等方面都有所不同。以下是轻量级锁和重量级锁的区别：
>
> ### 1. 实现方式
>
> - **轻量级锁**：
>   - 轻量级锁是基于 CAS（Compare-And-Swap）原子操作实现的。它通过在对象头的 Mark Word 中记录锁的状态和线程信息来实现锁的获取和释放。
>   - 当一个线程获取轻量级锁时，会将对象头的 Mark Word 复制到线程的栈帧中，并通过 CAS 操作更新 Mark Word 为锁定状态。如果 CAS 操作成功，则线程获取锁；如果失败，则说明有其他线程在竞争锁，此时轻量级锁可能会升级为重量级锁。
> - **重量级锁**：
>   - 重量级锁是基于操作系统的互斥量（mutex）实现的。它通过操作系统的内核态资源来实现线程的同步。
>   - 当一个线程获取重量级锁时，其他线程会被阻塞，进入等待队列，直到锁被释放。重量级锁涉及到操作系统的线程调度和上下文切换，开销较大。
>
> ### 2. 性能开销
>
> - **轻量级锁**：
>   - 轻量级锁的性能开销相对较小。它通过 CAS 操作实现锁的获取和释放，这些操作通常在用户态完成，不需要切换到内核态。
>   - 适用于线程间竞争不激烈的场景。如果线程竞争激烈，轻量级锁可能会频繁升级为重量级锁，导致性能下降。
> - **重量级锁**：
>   - 重量级锁的性能开销较大。它涉及到操作系统的线程调度和上下文切换，这些操作需要在内核态完成，开销较高。
>   - 适用于线程间竞争激烈的场景。虽然开销较大，但可以有效保证线程间的同步和一致性。
>
> ### 3. 锁的状态
>
> - **轻量级锁**：
>   - 轻量级锁的状态包括无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。
>   - 轻量级锁可以通过偏向锁优化，减少同一线程多次获取锁的开销。
> - **重量级锁**：
>   - 重量级锁的状态是固定的，一旦升级为重量级锁，锁的状态会一直保持到锁被释放。
>
> ### 4. 线程阻塞和唤醒
>
> - **轻量级锁**：
>   - 轻量级锁在竞争不激烈的情况下，线程不会被阻塞。如果竞争激烈，轻量级锁会升级为重量级锁，此时线程会被阻塞。
> - **重量级锁**：
>   - 重量级锁会直接导致线程阻塞。当一个线程获取重量级锁时，其他线程会被阻塞，进入等待队列，直到锁被释放。
>
> ### 5. 适用场景
>
> - **轻量级锁**：
>   - 适用于线程间竞争不激烈的场景，如单线程或少量线程访问共享资源。
>   - 适用于短时间持有锁的场景，如快速的同步操作。
> - **重量级锁**：
>   - 适用于线程间竞争激烈的场景，如多个线程频繁访问共享资源。
>   - 适用于长时间持有锁的场景，如复杂的同步操作。
>
> ### 总结
>
> - **轻量级锁**：基于 CAS 操作，性能开销小，适用于线程间竞争不激烈的场景。
> - **重量级锁**：基于操作系统的互斥量，性能开销大，适用于线程间竞争激烈的场景。
>
> 通过合理选择锁的级别，可以有效优化多线程程序的性能。在实际开发中，应根据具体场景选择合适的锁机制，以平衡性能和线程安全。

-------

## 锁分类表格（含 Java 样例）



| 类别            | 子类别     | 锁类型                            | 简要说明                                                     | Java 样例                                                    |
| --------------- | ---------- | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 基于实现方式 | 1.1 软件锁 | **互斥锁 (Mutex)**                | 确保同一时刻只有一个线程访问共享资源，其他线程阻塞等待。     | synchronized 关键字、java.util.concurrent.locks.ReentrantLock |
|                 |            | **读写锁**                        | 允许多个线程同时读，但写操作互斥，读锁共享，写锁独占。       | java.util.concurrent.locks.ReadWriteLock、ReentrantReadWriteLock |
|                 |            | 信号量 (Semaphore)                | 控制固定数量的线程访问资源，可允许多个线程同时访问，受限于许可数。 | java.util.concurrent.Semaphore                               |
|                 |            | **条件变量 (Condition Variable)** | 与互斥锁配合，允许线程等待特定条件，常用于线程协作。         | java.util.concurrent.locks.Lock 和 Condition（如 ReentrantLock.newCondition()） |
|                 |            | **管程 (Monitor)**                | 封装互斥锁和条件变量，提供高级同步机制，自动管理锁的获取和释放。 | synchronized 关键字（Java 内置管程）、java.util.concurrent.locks.Lock |
|                 | 1.2 硬件锁 | 测试并设置锁 (Test-and-Set)       | 通过硬件原子指令测试并设置标志位，实现互斥，可能导致忙等待。 | Java 无直接暴露，底层由 JVM 通过硬件指令（如 sun.misc.Unsafe）实现 |
|                 |            | **比较并交换锁 (CAS)**            | 通过硬件 CAS 指令实现无锁同步，比较内存值并交换，非阻塞。    | java.util.concurrent.atomic.AtomicInteger、AtomicBoolean（基于 CAS） |
|                 |            | 加载链接/条件存储 (LL/SC)         | 类似 CAS，提供灵活原子操作，常见于 RISC 架构，避免 ABA 问题。 | Java 无直接暴露，JVM 底层可能使用（如 HotSpot 实现 CAS 时优化） |
|                 |            | 获取并增加 (Fetch-and-Add)        | 原子性地获取值并增加，适合计数器场景。                       | java.util.concurrent.atomic.AtomicInteger.getAndIncrement()  |
| 2. 基于竞争程度 |            | **偏向锁 (Biased Lock)**          | 记录单一线程 ID，减少 CAS 操作，适合几乎无竞争场景。         | synchronized的优化机制（JVM 启用偏向锁，-XX:+UseBiasedLocking） |
|                 |            | **轻量级锁 (Lightweight Lock)**   | 通过 CAS 在对象头存储锁记录指针，避免操作系统锁，适合低竞争场景。 | synchronized的优化机制（JVM 自动升级为轻量级锁）             |
|                 |            | 重量级锁 (Heavyweight Lock)       | 依赖操作系统互斥锁，线程阻塞等待，适合高竞争场景。           | synchronized的优化机制（锁膨胀（升级）为重量级锁）           |
| 3. 基于并发策略 |            | 悲观锁 (Pessimistic Lock)         | 假定线程间会冲突，获取锁后独占资源，其他线程阻塞。           | synchronized关键字、java.util.concurrent.locks.ReentrantLock |
|                 |            | 乐观锁 (Optimistic Lock)          | 假定冲突较少，先操作数据，提交时检查冲突（如版本号或 CAS）。 | java.util.concurrent.atomic.AtomicInteger（CAS）、数据库版本号（如 JPA @Version） |
| 4. 基于功能特性 |            | 自旋锁 (Spin Lock)                | 未获取锁的线程循环尝试（忙等待），适合锁持有时间短的场景。   | java.util.concurrent.atomic 类的 CAS 操作（如 AtomicInteger.compareAndSet） |
|                 |            | 可重入锁 (Reentrant Lock)         | 同一线程可多次获取同一锁而不死锁，支持递归调用。             | synchronized关键字、java.util.concurrent.locks.ReentrantLock |
|                 |            | 公平锁 (Fair Lock)                | 按线程请求锁的顺序分配锁，避免线程饥饿。                     | java.util.concurrent.locks.ReentrantLock（构造时传入 fair=true） |
|                 |            | 非公平锁 (Non-Fair Lock)          | 不保证锁分配顺序，可能优先分配给刚到达的线程，性能较高。     | synchronized关键字、ReentrantLock（默认非公平模式）          |
|                 |            | 分布式锁                          | 跨进程或跨节点的锁机制，解决分布式系统资源竞争。             | Redis（SETNX 命令）、ZooKeeper（临时节点）、Redisson 框架    |
| 5. 特殊状态     |            | 死锁 (Deadlock)                   | 多个线程因相互等待对方释放锁而永久阻塞。                     | 无特定类，常见于 synchronized 或 ReentrantLock 使用不当（如交叉加锁） |
|                 |            | 活锁 (Livelock)                   | 线程不断尝试获取锁但无进展，处于活跃状态（如相互谦让）。     | 无特定类，常见于自旋锁或 CAS 重试场景，需通过随机退避解决    |
|                 |            | 锁粗化 (Lock Coarsening)          | JVM 优化，将多个小范围锁合并为一个大范围锁，减少加锁/解锁开销。 | synchronized的优化机制（JVM 自动优化，如 JIT 编译器合并循环内的锁） |
|                 |            | 锁消除 (Lock Elision)             | JVM 通过逃逸分析消除不必要的锁（如局部对象锁）。             | synchronized的优化机制（JVM 自动优化，如 JIT 编译器对非逃逸对象消除锁） |

------

补充说明与 Java 样例解析

1. 软件锁：

   - 互斥锁：synchronized 是 Java 的内置互斥锁机制，自动管理锁获取和释放。ReentrantLock 提供更灵活的控制，如超时获取锁。

     java

     ```java
     ReentrantLock lock = new ReentrantLock();
     lock.lock();
     try {
         // 访问共享资源
     } finally {
         lock.unlock();
     }
     ```

   - 读写锁：ReentrantReadWriteLock 允许多线程同时读，但写操作独占。

     java

     ```java
     ReadWriteLock rwLock = new ReentrantReadWriteLock();
     rwLock.readLock().lock(); // 读锁
     try {
         // 读操作
     } finally {
         rwLock.readLock().unlock();
     }
     ```

2. 硬件锁：

   - CAS：Java 的 AtomicInteger 使用 CAS 实现无锁同步，依赖底层硬件指令。

     java

     ```java
     AtomicInteger counter = new AtomicInteger(0);
     counter.compareAndSet(0, 1); // 原子操作
     ```

3. 竞争程度锁：

   - 偏向锁/轻量级锁/重量级锁：这些是 synchronized 的内部优化，由 JVM 自动管理。偏向锁和轻量级锁通过对象头的 Mark Word 实现，重量级锁依赖操作系统互斥锁。

     java

     ```java
     synchronized (obj) {
         // 可能为偏向锁、轻量级锁或重量级锁，视竞争情况
     }
     ```

4. 并发策略：

   - 乐观锁：AtomicInteger 使用 CAS 实现乐观锁，数据库中通过版本号（如 Hibernate 的 @Version）实现。

     java

     ```java
     AtomicInteger value = new AtomicInteger(0);
     value.compareAndSet(0, 1); // 乐观锁操作
     ```

5. 功能特性：

   - 分布式锁：使用 Redisson 框架实现 Redis 分布式锁。

     java

     ```java
     RedissonClient redisson = Redisson.create();
     RLock lock = redisson.getLock("myLock");
     lock.lock();
     try {
         // 分布式操作
     } finally {
         lock.unlock();
     }
     ```

6. 特殊状态：

   - 死锁：常见于不当使用 synchronized 或 ReentrantLock。

     java

     ```java
     Object lock1 = new Object(), lock2 = new Object();
     Thread t1 = new Thread(() -> {
         synchronized (lock1) {
             synchronized (lock2) { /* 可能死锁 */ }
         }
     });
     Thread t2 = new Thread(() -> {
         synchronized (lock2) {
             synchronized (lock1) { /* 可能死锁 */ }
         }
     });
     ```

   - 锁消除：JVM 自动优化，如对局部对象的 synchronized 消除。

     java

     ```java
     void method() {
         Object obj = new Object();
         synchronized (obj) { // JVM 可能消除此锁
             // 局部对象操作
         }
     }
     ```

------

备注

- JVM 优化：偏向锁、轻量级锁、重量级锁、锁粗化、锁消除由 JVM 自动管理，开发者无需显式配置，但可通过 JVM 参数（如 -XX:+UseBiasedLocking）调整。**JVM 的锁升级是单向的：无锁 → 偏向锁 → 轻量级锁 → 重量级锁。这意味着 synchronized 的行为在运行时可能从低开销的偏向锁开始，逐步升级到高开销的重量级锁，具体取决于线程竞争情况。这种动态调整完全由 JVM 管理，开发者只需使用 synchronized 关键字。**
- 无锁编程：CAS 和原子类（如 AtomicInteger）是无锁机制的基础，广泛用于高并发场景。
- 分布式锁：Redis 和 ZooKeeper 是主流实现，Redisson 提供了 Java 的高级封装。
- 死锁的四个必要条件：互斥、请求和保持条件、不可剥夺、循环等待
