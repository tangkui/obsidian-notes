---
title: 安全点
tags:
  - JVM
  - 安全点
  - 安全区域
  - GC
  - STW
---

# JVM 安全点 (Safepoint) 与安全区域 (Safe Region)

## 1. 什么是安全点
- **定义**：安全点（Safepoint）是 JVM 为了进行全局一致性操作（如 GC、偏向锁撤销、Deoptimization、类重定义）而设置的线程可安全停顿的位置。  
- **作用**：保证线程状态一致，JVM 可以安全操作堆和栈。

---

## 2. 什么是安全区域 (Safe Region)
- **定义**：线程当前不执行 Java 代码，也不修改堆或栈的状态区域。  
- **作用**：JVM 在执行全局操作时，不必等待这些线程，可以直接操作堆。  
- **特点**：
  - 线程已经进入阻塞或等待状态
  - 线程不会对堆/栈状态造成变化
  - 不会阻塞 GC 或其他全局操作

### 常见安全区域场景
- `Thread.sleep()` 或 `LockSupport.park()`  
- 阻塞 IO（例如读取文件、Socket）  
- `Object.wait()` 等线程等待  

---

## 3. 安全点触发的典型场景
- **垃圾回收（GC）**
- **偏向锁撤销**
- **类的 Redefine / Retransform**
- **Deoptimization（反优化）**

---

## 4. 安全点的位置
典型安全点包括：
- **方法调用**  
- **循环回跳**  
- **异常抛出**

### 示例代码
```java
public class SafepointDemo {
    public static void main(String[] args) {
        foo();  // 方法调用点 (安全点)

        for (int i = 0; i < 1000000; i++) {
            // 循环回跳处会检查安全点
        }

        try {
            throw new RuntimeException("test"); // 异常抛出处是安全点
        } catch (Exception e) {}
    }

    public static void foo() {
        System.out.println("method call");
    }
} 

``` 

## 5. 线程如何停在安全点

- JVM 设置 **全局 safepoint 标志**。
    
- 线程执行到安全点时轮询检查标志。
    
- 如果标志为 true，线程挂起。
    
- GC 或其他全局操作完成后，线程恢复。
    
> **线程暂停策略**：
> 1. 主动式中断：设置全局标志位线程运行到安全点时检查并主动挂起（现代JVM默认）
> 2. 抢占式中断：强制中断所有线程，恢复未达安全点的线程直接暂停（已淘汰）
---

## 6. 安全点 vs 安全区域

|概念|描述|示例|
|---|---|---|
|**安全点 (Safepoint)**|JVM 可以要求线程停下的代码位置，线程可能正在执行 Java 代码，需要主动挂起。|方法调用、循环回跳、异常抛出|
|**安全区域 (Safe Region)**|线程已经不再执行 Java 代码，不会修改堆或栈，JVM 无需等待。|`Thread.sleep()`, 阻塞 IO, `wait()`|

---

## 7. GC 与安全点的关系

### 7.1 Stop-The-World (STW)

- GC 需要全局操作时，会触发 **STW**。

> **定义**：STW 指JVM暂停所有用户线程;（如 GC 线程除外），使程序进入全局冻结状态。此时 Java 代码停止执行，但 Native 代码可运行（不能与 JVM 交互）。
> 
   **作用**：保证 JVM 可以在堆和栈上进行全局一致性操作，而不被其他线程修改。 
> 
> **底层原理**：其本质是**安全点**、**安全区域**的实现
   

- 流程依赖安全点：
    
    1. JVM 设置全局 safepoint 标志
        
    2. 所有线程运行到安全点时挂起
        
    3. GC 扫描堆和 GC Roots
        
    4. GC 完成，清除标志，线程恢复执行
        

### 7.2 安全点的分布对 GC 停顿的影响

- 安全点太少 → 长时间循环延迟 STW → 停顿变长
    
- 安全点太密 → 轮询开销增加
    

### 7.3 GC Roots 枚举

- 线程停在安全点，栈帧和寄存器状态稳定，才能正确枚举 GC Roots。
    

---

## 8. 疑问与解答

**Q1: 堆是在主存吗？是内存快照吗？**

- A：是的，堆在主存中。Heap Dump 是物理层面的快照；GC 的堆一致性快照是逻辑上的。
    

**Q2: 为什么线程要等到方法调用 / 循环跳转 / 异常点才能停下？**

- A：这些是“状态一致点”，保证栈帧和寄存器完整。
    

**Q3: Safepoint 和 Safe Region 有什么区别？**

- A：Safepoint 是线程可能在执行 Java 代码，需要主动检查；Safe Region 是线程不影响堆状态，JVM 不用等待。
    

---

## 9. 小结

- **安全点 = JVM 可以安全停顿的代码位置**
    
- **安全区域 = 不会修改堆/栈的线程状态**
    
- GC/STW 必须依赖安全点来保证堆一致性
    
- 安全点分布影响停顿时间与性能
    
- 核心思想：**在状态一致点挂起线程，保证全局操作安全**
    

---

## 10. 示意图

### 10.1 线程执行到安全点停下 vs GC 扫描堆
``` mermaid
sequenceDiagram
    participant JVM
    participant ThreadA
    participant ThreadB
    JVM->>All Threads: 设置 SafepointFlag = true
    Note over ThreadA,ThreadB: 线程继续执行
    ThreadA->>ThreadA: 到达方法调用/循环回跳/异常点
    ThreadA->>JVM: 挂起
    ThreadB->>ThreadB: 到达安全点
    ThreadB->>JVM: 挂起
    JVM->>JVM: 所有线程挂起后执行 GC
    JVM->>All Threads: 清除 SafepointFlag，恢复线程

``` 


### 10.2 Safepoint vs Safe Region 对比

``` mermaid 
flowchart LR
    A[线程执行 Java 代码] --> B{是否到达安全点?}
    B -- 是 --> C[检查 SafepointFlag]
    C -- true --> D[线程挂起，等待全局操作]
    C -- false --> A[继续执行]
    B -- 否 --> E[线程继续执行指令]
    F[线程阻塞/等待/IO] --> G[安全区域]
    G --> H[JVM 无需等待，可以执行 GC 或全局操作]

``` 

## 11. 线程修改引用 vs GC 扫描堆

### 11.1 场景说明
- 线程正在修改对象引用（Thread-local 视角）：
  - 它认为操作是原子的
  - 但是 GC 可能在中途观察到“中间状态”
- JVM 全局视角：
  - GC 需要堆的一致快照
  - 如果线程没有停在安全点，可能看到“部分修改”的堆 → 内存不一致

### 11.2 逻辑示意图 
``` mermaid 
sequenceDiagram
    participant ThreadA
    participant ThreadB
    participant GC
    Note over ThreadA: 正在执行对象修改操作
    ThreadA->>ThreadA: obj.field = newValue
    Note over GC: GC 准备开始扫描堆
    GC->>ThreadA: 请求进入 Safepoint
    Note over ThreadA: 线程继续执行，未到安全点
    ThreadA->>ThreadA: obj.field = anotherValue
    Note over GC: GC 无法获取一致堆快照，等待线程到安全点
    ThreadA->>GC: 到达安全点，挂起
    GC->>GC: 扫描堆、枚举 GC Roots
    GC->>ThreadA: 完成 GC，线程恢复执行
``` 
