---
title: 运算
tags:
  - 数学
  - 运算
  - 计算
---
# 位运算
## 左移(<<)
### 概念 

$$
\begin{align}
&\text{1.数学角度：左移 } n \text{ 位相当于将数值乘以 } 2^n \text{（前提是没有溢出）。} \\
&\text{2.二进制中，左移一位等于乘以 } 2\text{，左移两位等于乘以 } 2^2 = 4。 \\
&\text{3. 示例:}5 \ll 2=20用二进制表示00000101 \ll 2 = 00010100
\end{align}
$$
**过程：**
- 原始二进制：00000101。
- 左移 1 位：00001010（最左边的 0 被移出丢弃，最右边补 0）。
- 左移 2 位：00010100（再次左移，最左边的 0 被移出丢弃，最右边补 0）。

**JAVA 语法示例**
``` java
// 表示1的二进制左移4位：高位删除，低位补零,也就是(1*2的4次方):1*2*2*2*2=16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

**注意事项**
$$
\begin{align}
&\text{1.位数表示：示例中} 00000101 \text{是} 8 \text{位表示，但 Java 的 int 是} 32 \text{位}\\
&{2.实际为00000000\_00000000\_00000000\_00000101。 }\\
&{3. 左移后，结果是 00000000\_00000000\_00000000\_00010100。 }\\
&{4. 以上8 位简化是为了方便说明。}\\
&{5. 溢出：如果左移导致最高位（符号位）变化，可能从正数变为负数，}\\
&{6. 但这里} 5 \ll 2 \text{远未达到 int 的范围（}2^{31} -1
\text{）。}
\end{align}
$$

## 右移(>>)

### 概念
 $$
\begin{align}
&\text{数学意义：右移 `n` 位，相当于除以}2^n \&text{并向下取整。}\\
&\text{二进制意义：每次右移 1 位，整体往右移动一格，高位补符号位（算术右移）。}\\
&\text{正数补 0}\\
&\text{负数补 1}
\end{align}
$$
### 示例

正数示例：
``` java
int a = 20;     // 二进制: 00000000 00000000 00000000 00010100
int b = a >> 2; // 结果:   00000000 00000000 00000000 00000101 -> b = 5
```

负数示例：
```java
int a = -20;    // 二进制: 11111111 11111111 11111111 11101100
int b = a >> 2; // 结果:   11111111 11111111 11111111 11111011 -> b = -5
```


## 无符号右移(逻辑右移>>>)
### 概念

- **逻辑右移**：无论正负数，高位一律补 `0`。
    
- 对于正数，`>>>` 与 `>>` 结果相同。
    
- 对于负数，结果会变成一个很大的正数。
### 示例
``` java
int a = -20;     // 二进制: 11111111 11111111 11111111 11101100
int b = a >>> 2; // 结果:  00111111 11111111 11111111 11111011 -> b = 1073741819
``` 
## 位移运算总结

| 运算符   | 名称        | 高位补位  | 数学含义                                                 | 示例                       |
| ----- | --------- | ----- | ---------------------------------------------------- | ------------------------ |
| `<<`  | 左移        | 低位补 0 | $$\begin{align}\text{乘以}2^n \end{align}$$            | `5 << 2 = 20`            |
| `>>`  | 算术右移      | 符号位补  | $$\begin{align}\text{除以}2^n \text{向下取整}\end{align}$$ | `-20 >> 2 = -5`          |
| `>>>` | 逻辑右移（无符号） | 高位补 0 | 逻辑右移，无符号效果                                           | `-20 >>> 2 = 1073741819` |

## 按位与(&)
## 运算规则

- 按位与，就是对 **每一位二进制数** 单独进行 **逻辑与** 运算：
    
- 规则：

|A|B|A & B|
|---|---|---|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

即：**只有两个位都为 1，结果才为 1**。

---

## 2. 示例

### 示例 1：正数

`int a = 5;   // 二进制: 0101 int b = 3;   // 二进制: 0011 int c = a & b;` 

逐位计算：

  `0101   (5) & 0011   (3) = 0001   (1)`

所以 `5 & 3 = 1`。

---

### 示例 2：和 1 做 &

`int x = 7;  // 0111 int y = x & 1; // 结果 1`

规律：

- **任意数 & 1 = 最后一位**。
    
- 如果最后一位是 0 → 偶数
    
- 如果最后一位是 1 → 奇数
    

📌 **用途：判断奇偶数**。

---

### 示例 3：和 0 做 &

`int x = 123; int y = x & 0; // 永远是 0`

规律：

- **任意数 & 0 = 0**。
    

📌 **用途：清零操作**。

---

### 示例 4：掩码应用（取指定位）

``` java 
int FLAG_READ  = 1 << 0; // 0001 
int FLAG_WRITE = 1 << 1; // 0010  
int permission = 3; // 0011（二进制），表示同时有读和写权限  
boolean canRead  = (permission & FLAG_READ) != 0;  // true 
boolean canWrite = (permission & FLAG_WRITE) != 0; // true
``` 

逐位来看：

  ``` text 
  permission: 0011 & FLAG_READ: 0001 = 0001  -> 非0，说明有读权限
  ```

📌 **用途：位掩码（权限控制、状态标记）**。

---

## 3. 直观理解

你可以把 `&` 理解为：

- **过滤器（mask）** → 把你不关心的位清零，把关心的位保留下来。
    
- `& 1` = 只看最后一位
    
- `& 0xFF` = 只看最后 8 位
    
- `& mask` = 只取 mask 为 1 的位置