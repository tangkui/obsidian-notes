
# 📚 MySQL 锁等待超时问题排查与解决手册

> **问题：`Lock wait timeout exceeded; try restarting transaction` 插入 `dc_order_exception` 表失败**

---

## 🔍 一、问题现象

  
- 系统频繁报错：com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException:Lock wait timeout exceeded; try restarting transaction

  

- SQL 操作：`INSERT INTO dc_order_exception`
- 调用链路：MQ → OrderSyncService → CreatedSyncService → saveOrderException()
- 高并发场景下偶发，但影响核心订单流程。

---

## 🧩 二、根本原因分析

### ❌ 根本原因：

> **外层大事务未提交，导致其持有的 GAP 锁长期不释放，阻塞了其他线程对 `dc_order_exception` 表的插入操作。**

具体表现为：

- 外层事务（T1）执行时间长（包含远程调用、复杂逻辑）；
- 内部 `saveOrderException()` 方法虽使用 `REQUIRES_NEW`，但仍可能因索引间隙锁冲突被阻塞；
- 或 `deleteOrderException` 未加 `REQUIRES_NEW`，继承了外层事务，延长锁持有时间；
- 最终多个线程竞争同一索引区间的 gap lock，造成锁等待超时。

---

## 🕵️‍♂️ 三、关键排查手段

### 1. 查看当前运行事务

```sql
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMEDIFF(NOW(), trx_started) AS duration,
    trx_mysql_thread_id,
    trx_query 
FROM information_schema.innodb_trx;

👉 关注：长时间运行、状态为 `RUNNING` 但 `trx_query = NULL` 的“空跑”事务。

```

### 2. 查看锁等待情况
``` sql
-- 阻塞者 & 等待者
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

### 3. 检查表结构

``` sql
SHOW CREATE TABLE dc_order_exception;
SHOW INDEX FROM dc_order_exception;
```

重点关注：

- 是否有主键？
- 是否允许过多 `NULL` 字段？
- 索引是否合理？

---

## 🛠️ 四、解决方案汇总

| 类型      | 措施                                           | 说明                                                          |
| ------- | -------------------------------------------- | ----------------------------------------------------------- |
| ✅ 应急处理  | `KILL <trx_mysql_thread_id>`                 | 终止长时间运行的阻塞事务                                                |
| ✅ 代码修复  | `@Transactional(propagation = REQUIRES_NEW)` | 给 `save/deleteOrderException` 加独立事务                         |
| ✅ 数据库优化 | 添加复合索引                                       | `idx_order_id_exception_id`, `idx_process_flag_create_time` |
| ✅ 字段规范  | 修改字段为 `NOT NULL`                             | 如 `create_time`, `update_time`                              |
| ✅ 架构优化  | 使用 Spring Event 异步处理异常                       | 解耦核心流程与副作用                                                  |
| ✅ 安全兜底  | 设置事务超时                                       | `@Transactional(timeout = 15)`                              |
| ✅ 监控告警  | 定期巡检长事务                                      | 脚本 + Prometheus + Grafana                                   |

---

## 💡 五、最佳实践建议

### 1. 事务设计原则

|操作类型|建议传播行为|原因|
|---|---|---|
|记录异常日志|`REQUIRES_NEW`|快速提交，避免被主事务拖累|
|删除异常记录|`REQUIRES_NEW`|同上|
|更新订单状态|`REQUIRED`|必须与主事务一致|
|查询异常列表|`readOnly = true`|减少锁竞争|

### 2. 表设计规范

``` sql
-- 推荐结构
CREATE TABLE dc_order_exception (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id VARCHAR(64) NOT NULL,
    exception_id BIGINT NOT NULL,
    action_type VARCHAR(32) NOT NULL,
    exception_type VARCHAR(50) NOT NULL,
    exception_message TEXT,
    process_flag TINYINT NOT NULL DEFAULT 0,
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_order_id (order_id),
    INDEX idx_exception_id (exception_id),
    INDEX idx_order_id_exception_id (order_id, exception_id),
    INDEX idx_process_flag_create_time (process_flag, create_time)
);
```

### 3. 调用顺序注意
``` java
// ✅ 正确：先落库，再写异常

orderRepository.save(order); // 先提交订单

orderExceptionService.saveOrderException(orderId, ...); // 再记录异常

  

// ❌ 错误：异常写在订单之前

orderExceptionService.saveOrderException(...); // 可能出现“孤儿异常”

orderRepository.save(order); // 后续失败回滚
```

---

## 🚨 六、常见误区提醒

|误区|正确认知|
|---|---|
|“只有 UPDATE 才会锁表”|INSERT 也会因 gap lock 被阻塞|
|“REQUIRES_NEW 一定能快速提交”|如果底层锁被别人占着，它也会等|
|“只要加了索引就安全”|单列索引不够，需根据查询条件建复合索引|
|“事务越小越好”|过度拆分会导致一致性问题，要权衡业务语义|

---

## 📎 七、附加工具脚本

### 1. 检测长事务脚本（Shell）

```
#!/bin/bash
RESULT=$(mysql -u user -ppass -h host -sNe "
SELECT trx_mysql_thread_id 
FROM information_schema.innodb_trx 
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 30
")

for thread_id in $RESULT; do
    echo "Killing long-running transaction: $thread_id"
    mysql -u user -ppass -h host -e "KILL $thread_id;"
done
```

### 2. Spring Event 示例（解耦异常处理）
``` java
// 发布事件

eventPublisher.publishEvent(new OrderCreateFailedEvent(orderId, failedReason));


// 监听器

@EventListener

@Transactional(propagation = Propagation.REQUIRES_NEW)

public void handleOrderCreateFailed(OrderCreateFailedEvent event) {

orderExceptionService.saveOrderException(event.getOrderId(), event.getReason());

}
```


---

## ✅ 八、总结一句话

> **不要让“记录异常”的逻辑，反过来成为系统最大的异常来源。**
> 
> 合理使用 `REQUIRES_NEW` + 复合索引 + 事件驱动，才能既保证性能又不失一致性。
