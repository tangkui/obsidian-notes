# MySQL 事务隔离级别笔记

## 1. 四种隔离级别对比

| 隔离级别              | 脏读 | 不可重复读 | 幻读 | MySQL 默认 | 实现机制 | 性能 |
|-----------------------|------|------------|------|------------|----------|------|
| READ UNCOMMITTED      | ✅ 可能 | ✅ 可能    | ✅ 可能 | ❌ | 直接读最新数据 | 最快 |
| READ COMMITTED        | ❌ 避免 | ✅ 可能    | ✅ 可能 | Oracle 默认 | MVCC（快照读） | 较快 |
| REPEATABLE READ       | ❌ 避免 | ❌ 避免    | ❌ 避免（InnoDB 特性） | ✅ InnoDB 默认 | MVCC + Next-Key Lock | 中等 |
| SERIALIZABLE          | ❌ 避免 | ❌ 避免    | ❌ 避免 | ❌ | 全表/区间加锁 | 最慢 |

---

## 2. 三大并发问题举例

### 🔹 脏读（Dirty Read）
读到了其他事务**未提交的数据**。
```text
事务A：UPDATE account SET balance=50 WHERE id=1; （未提交）
事务B：SELECT balance FROM account WHERE id=1; → 读到 50
事务A：ROLLBACK;
最终实际是 100，但事务B读到过 50。 
``` 

### 🔹 不可重复读（Non-repeatable Read）

同一事务中，多次读取**同一行结果不一致**。

`事务A：SELECT balance FROM account WHERE id=1; → 100 事务B：UPDATE account SET balance=50 WHERE id=1; COMMIT; 事务A：再次 SELECT balance FROM account WHERE id=1; → 50`

### 🔹 幻读（Phantom Read）

同一事务中，多次读取**符合条件的记录数量不一致**。

`事务A：SELECT * FROM orders WHERE amount > 100; → 10 行 事务B：INSERT INTO orders(id, amount) VALUES(99, 200); COMMIT; 事务A：再次 SELECT * FROM orders WHERE amount > 100; → 11 行`

➡ 事务A“看到了幽灵般新增的数据”。

---

## 3. MVCC（多版本并发控制）

- **是什么**：每条记录有多个版本（隐藏列：事务ID、回滚指针），事务通过“版本快照”来读数据。
    
- **作用**：让事务在 RC 和 RR 下可以读到自己应看到的历史版本，MVCC 的本质是解决“脏读”和“读写阻塞”问题，通过历史版本和快照，让读取操作更高效、更安全。

- **注意**： MVCC 本身提供快照机制，能避免脏读；要避免不可重复读，必须使用 Repeatable Read 或更高隔离级别（不可重复读、幻读依赖隔离级别和锁策略，不是 MVCC 单独能解决的。）。

- **是否加锁**：不加锁，读写不冲突，性能高。
    
- **使用范围**：
    
    - **普通 `SELECT`（快照读）** 在 RC、RR 下使用 MVCC（RC + MVCC可能会产生可重复读，RR + MVCC 则可以避免）。
        
    - 在 RU 下直接读最新版本，不用 MVCC。
        
    - 在 SERIALIZABLE 下直接加锁，也不用 MVCC。
        

**例子**：

- 事务A启动时读到余额=100；
    
- 事务B改成50并提交；
    
- 事务A再次读，仍然是100（历史快照）。
    

---

## 4. Next-Key Lock（记录锁 + 间隙锁）

- **是什么**：InnoDB 特有锁，锁定某条索引记录和它前面的间隙，防止别的事务插入。
    
- **作用**：解决幻读问题。
    
- **是否加锁**：会加锁，降低并发性能。
    
- **使用范围**：
    
    - RR 隔离级别下的 **加锁读/写操作**：
        
        - `SELECT ... FOR UPDATE`
            
        - `SELECT ... LOCK IN SHARE MODE`
            
        - `UPDATE ...`
            
        - `DELETE ...`
            
    - RC 下默认只有行锁，不加间隙锁，可能出现幻读。
        
    - 普通 `SELECT` 不使用 Next-Key Lock，而是 MVCC。
        

**举例：**

`-- 表里有 id=10, 20, 30 事务A: SELECT * FROM t WHERE id BETWEEN 10 AND 30 FOR UPDATE;`

InnoDB 会加锁：

- 记录锁：id=10, id=20, id=30
    
- 间隙锁：(10,20)、(20,30)
    

➡ 防止别的事务插入 id=15、25 这样的新记录，避免幻读。

- 可以通过 **`SHOW ENGINE INNODB STATUS\G`** 来查看锁信息。典型输出如下：
``` sql
TRANSACTION 12345, ACTIVE 0 sec
MySQL thread id 10, OS thread handle 123456
LOCK WAIT 5 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 1
MySQL thread id 11, query ...
RECORD LOCKS space id 123 page no 456 n bits 72 index `PRIMARY` of table `test`.`users` trx id 12345 lock_mode X locks rec but not gap
RECORD LOCKS space id 123 page no 456 n bits 72 index `PRIMARY` of table `test`.`users` trx id 12345 lock_mode X locks gap before rec
```
- **`locks rec but not gap`** → 纯行锁
    
- **`locks gap before rec`** → 间隙锁
    
- **两者同时出现** → 就是 **Next-Key Lock**
---

## 5. 总结表

|隔离级别|是否用 MVCC|是否用 Next-Key Lock|幻读情况|典型场景|
|---|---|---|---|---|
|READ UNCOMMITTED|❌|❌|可能|基本不用|
|READ COMMITTED|✅ 普通SELECT|❌（只行锁）|可能|Oracle 默认|
|REPEATABLE READ|✅ 普通SELECT|✅ 加锁读/写操作|避免|MySQL 默认|
|SERIALIZABLE|❌|❌（直接全表/范围锁）|避免|高一致性要求，低并发|

---

## 6. 实际建议

1. **业务开发中常用 REPEATABLE READ（MySQL 默认）**，既安全又性能平衡。
    
2. **READ COMMITTED** 在 Oracle 里更常见，但在 MySQL 可能导致幻读。
    
3. **普通查询 SELECT 用 MVCC**，不会阻塞；加锁查询才会用 Next-Key Lock。
    
4. 写 SQL 时要注意：
    
    - 用索引才能减少锁范围；
        
    - 无索引条件可能导致锁全表。
